<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>[ReactJS]ReactJS, AKA the V in MVC</title>

</head>
<body>
<h1>[ReactJS]ReactJS, AKA the V in MVC</h1>

<p><img src="https://dl.dropboxusercontent.com/u/20925528/%E6%8A%80%E8%A1%93Blog/blogs/FLUX%2BReactJS/02/ReactJS.png" alt="ReactJS" /></p>

<h2>ReactJS Intro</h2>

<p>ReactJS是Facebook推出的framework, 再搭配FLUX的架構下讓FB網頁上面更新資料的快速性與開發架構得到的顯著改善，也因此讓大家開始想去了解它的魅力。這邊用官網的三段特色描述來簡單介紹：</p>

<ul>
<li><h3>VIRTUAL DOM</h3>

<p>  React abstracts away the DOM from you, giving a simpler programming model and better performance. React can also render on the server using Node, and it can power native apps using React Native.</p></li>
<li><h3>DATA FLOW</h3>

<p>  React implements one-way reactive data flow which reduces boilerplate and is easier to reason about than traditional data binding.</p></li>
<li><h3>JUST THE UI</h3>

<p>  Lots of people use React as the V in MVC. Since React makes no assumptions about the rest of your technology stack, it's easy to try it out on a small feature in an existing project.</p></li>
</ul>


<p>以往我們所知用更改一個DOM的Element來呈現畫面改變的這個方法在大型頻繁更新的網站上面是非常可怕的效能瓶頸。可以看到的是ReactJS要解決的是Web開發上面UI呈現的問題，隨者網頁功能越多與越多人互相使用與交流，FB遇到越來越多需要在同一個頁面即時更新的情況，ReactJS就是因此而誕生的一個Framework．</p>

<p>而呼應FLUX架構，ReactJS用更簡單的流程來管理頁面的更新，透過事件的訂閱與註冊的概念產生單一方向的處理流程，簡化如MVC, MVVM等架構對於View方面雙向溝通的方式。而也因為是針對UI(View)處理所產生的framework，所以要結合回去你原本的AngularJS這種MVC框架也是可行的。</p>

<h3>AKA V in MVC</h3>

<p>React : Rethinking Best Practices. 這是我覺得對於ReactJS還不錯的一個解釋</p>

<ul>
<li>React 的設計 - 每個更新UI(View)等同於整個畫面重新繪製</li>
<li>React 的實作 - Virtual DOM與Event</li>
</ul>


<iframe src="//www.slideshare.net/slideshow/embed_code/key/9yHWlcJx1bWShG" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/floydophone/react-preso-v2" title="Rethinking Best Practices" target="_blank">Rethinking Best Practices</a> </strong> from <strong><a href="//www.slideshare.net/floydophone" target="_blank">floydophone</a></strong> </div></p>

<p>其中第4-6頁的簡單幾句話已經明確說明它的定位。</p>

<h3>使用ReactJS</h3>

<p>可以到官方網站透過<a href="http://facebook.github.io/react/docs/getting-started.html">React starter kit</a>取得最新的範例跟JS檔案或是參考官方<a href="https://cdnjs.com/libraries/react/">CDN</a></p>

<p>如果有安裝Nodejs也可以透過使用官方的工具幫你建置開發環境</p>

<pre><code>$ npm install -g react-tools
</code></pre>

<p>如果你在使用上有需要用任何Add-ons，則使用下面的方式引入你的專案</p>

<pre><code>var React = require('react/addons'); instead.
</code></pre>

<p>當然你也可以用Bower統一下載</p>

<pre><code>$ bower install --save react
</code></pre>

<p>這邊我們就直接用JSBin帶大家一起說聲Hello world</p>

<h4>Hello world</h4>

<p><a class="jsbin-embed" href="http://jsbin.com/kixotojavo/2/embed?html,js,output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>很簡單的只要在HTML頁面放好一個div tag,並透過React render出所需要呈現的畫面裡面有什麼(這邊製作了一個div的Element並在裡面放入文字)，並讓這個建置他的物件本身的Name的屬性可以被傳入內部配合處理。</p>

<h3>JSX and Hello world with JSX Syntax</h3>

<h4>JSX</h4>

<p>在已經習慣寫XML的情況下要我們產生一個div物件很簡單，但在剛剛說Hello world的時候我們怎麼知道要怎麼產生出一個div物件呢？</p>

<p>React為了讓開發方便就同時提出了一個JSX syntax的方式，接下來我們直接看看JSX的話會長什麼樣子吧</p>

<pre><code>var HelloMessage = React.createClass({
    render: function() {
        return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;
    }
});

React.render(&lt;HelloMessage name="Blackie" /&gt;, mountNode);
</code></pre>

<p>有沒有覺得很熟悉很簡單了，透過JSX我們可以快速地進行開發</p>

<h4>Hello world with JSX Syntax</h4>

<p><a class="jsbin-embed" href="http://jsbin.com/zezebu/3/embed?html,js,output">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script></p>

<p>因為如果使用一般的JS Bin會出現下面的錯誤</p>

<p><img src="https://dl.dropboxusercontent.com/u/20925528/%E6%8A%80%E8%A1%93Blog/blogs/FLUX%2BReactJS/02/JS%20Bin%20Error.png" alt="Error" /></p>

<p>這邊為了做出JSX可以在JS Bin上面執行的結果使用了<a href="http://react.rocks/example/6to5_JSBin">6to5 JS Bin</a></p>

<p>可以看到如果使用JSX的話記得要加上</p>

<pre><code>&lt;script src="xxxx/JSXTransformer.js"&gt;&lt;/script&gt;
</code></pre>

<p>這行的作用，主要就是去讓JSXTransformer.js查詢並針對所有的script type為text/jsx的內容作轉換。</p>

<p>在開發的時候我們可以透過JSX幫我快速地寫出我們想要的畫面，但因為JSX是一種結合XML語法的pre-compile結果，所以如果是要正式發佈的話還是轉換成純Javascript的內容，這樣才可以使render產生畫面的速度加快。</p>

<h2>結語</h2>

<p>看完介紹與簡單實作，總結一下為什麼想用Reactjs</p>

<ul>
<li>單一流程

<ul>
<li>簡化以往對於UI(View)更新的方向，捨棄資料綁定的概念，改用重繪的架構，確保每個資料都能夠更新並顯示。這使得發生問題或新增修改功能時會更加快速上手</li>
</ul>
</li>
<li>Virtual DOM

<ul>
<li>比操作DOM來說效能更好的解決方法，能在大量且頻繁的更新情況下，更快速的反應畫面異動結果</li>
</ul>
</li>
<li>強化Component概念

<ul>
<li>強化小模組單一功能的component。這除了縮小每個功能的開發範圍與可重複利用重組任意
Component，也讓測試可以被執行也應該要以測試為前提進行開發(TDD)</li>
</ul>
</li>
</ul>


<p>下一次會用簡單的Demo解說React如何使用FLUX這個架構，有興趣先了解FLUX的流程可以先參考另外一篇<a href="http://www.dotblogs.com.tw/blackie1019/archive/2015/04/14/151049.aspx">[FLUX]FLUX架構介紹與實作FLUX架構
</a></p>

<h2>Ref</h2>

<ul>
<li><a href="http://jamestw.logdown.com/posts/207346-a-preliminary-study-on-reactjs">初探Reactjs</a></li>
<li><a href="http://www.sitepoint.com/getting-started-react-jsx/">Getting Started with React and JSX</a></li>
<li><a href="http://www.tivix.com/blog/react-js-the-new-kid-on-the-block/">React JS: The new kid on the block</a></li>
</ul>

</body>
</html>